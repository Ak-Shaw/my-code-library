/*

A function generates values that can be plotted as a line graph.

Peaks are points at which the function output changes from increasing 
to decreasing and troughs are points at which the function output 
changes from decreasing to increasing.

The first or last value in the graph is either a peak or trough 
depending on whether it is greater than or lesser than its 
neighboring value. If it is equal, it is neither a peak nor a trough.

Given the output of this function, find the maximum distance between 
any two consecutive peaks or two consecutive troughs.

Note: distance is the difference in the index at which the value 
occurs

Function Description
Input Format:

The first line contains an integer, n, where n denotes the 
number of values generated.

Each line i of the n subsequent lines ( where 0 <= i < n) contains 
the ith value generated by the function.

Output Format:

Print a single integer denoting the maximum distance between any 
two consecutive peaks or two consecutive troughs.

Constraints
• 1 <= n <= 105

• 1 <= values generated by the function <= 105

• It is guaranteed that there will only be one key with 
the worst time. Input Format For Custom Testing

Sample Input
8 
5 
10
5
7
3
2
4
5
Sample Output
4
Explanation:
The peaks are 10, 7 and 5. Troughs are 5, 5 and 2.

The maximum distance is between 7 and 5 which is 4.

*/

import java.util.*;

public class PeakAndTrough{

	public static void main(String[] args) {
		
		Scanner sc=new Scanner(System.in);

		byte n=sc.nextByte();

		if(n<3){
			System.out.println(0);
			return;
		}

		byte[] functionValues=new byte[n];

		for(byte i=0; i<n; i++)
			functionValues[i]=sc.nextByte();

		byte[] peaks=getPeaks(functionValues);
		byte[] troughs=getTroughs(functionValues);

		byte maxDistPeaks=maxSeparation(peaks);
		byte maxDistTroughs=maxSeparation(troughs);

		if(maxDistPeaks>maxDistTroughs)
			System.out.println(maxDistPeaks);
		else
			System.out.println(maxDistTroughs);
	}

	private static byte[] getPeaks(byte[] functionValues){

		byte n=(byte)functionValues.length;

		byte[] peaks=new byte[n];

		if(functionValues[0]>functionValues[1])
			peaks[0]=1;

		if(functionValues[n-1]>functionValues[n-2])
			peaks[n-1]=1;

		for(byte i=1; i<n-1; i++){

			if(functionValues[i]>functionValues[i-1] && functionValues[i]>functionValues[i+1])
				peaks[i]=1;

		}

		return peaks;

	}

	private static byte[] getTroughs(byte[] functionValues){

		byte n=(byte)functionValues.length;

		byte[] troughs=new byte[n];

		if(functionValues[0]<functionValues[1])
			troughs[0]=1;

		if(functionValues[n-1]<functionValues[n-2])
			troughs[n-1]=1;

		for(byte i=1; i<n-1; i++){

			if(functionValues[i]<functionValues[i-1] && functionValues[i]<functionValues[i+1])
				troughs[i]=1;

		}

		return troughs;

	}

	private static byte maxSeparation(byte[] bits){

		byte n=(byte)bits.length;

		byte lastIndex=-1;

		byte dist=0;

		for(byte i=0; i<n; i++){

			if(lastIndex==-1 && bits[i]==1){
				lastIndex=i;
				continue;
			}

			byte currentIndex;

			if(bits[i]==1){

				currentIndex=i;

				if(currentIndex-lastIndex>dist){

					dist=(byte)(currentIndex-lastIndex);

				}

				lastIndex=i;

			}

		}

		return dist;

	}
}